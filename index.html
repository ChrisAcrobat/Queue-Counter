<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Queue counter</title>
		<meta content="width=device-width, initial-scale=1.0" name="viewport">
		<meta content="yes" name="mobile-web-app-capable">
		<style>
			@font-face{
				font-family:'digital-clock-font';
				src: url('digital-7/digital-7 (mono).ttf');
			}
			html, body, #counter {
				height: 100%;
				margin: 0;
				padding: 0;
				color: white;
				background-color: black;
			}
			#error-message {
				color: red;
			}
			#admin {
				color: black;
				background-color: white;
				height: 100%;
			}
			#admin > * {
				padding: 8px;
			}
			#terminal {
				height: 100%;
			}
			#terminals {
				width: fit-content;
			}
			.terminal-item {
				display: flex;
			}
			#terminal-config-queues {
				display: flex;
			}
			#terminal-config-queues>* {
				flex-grow: 1;
			}
			.center-height {
				display: flex;
				height: 100%;
				justify-content: center;
				align-items: center;
			}
			.center-width {
				display: flex;
				justify-content: center;
				align-items: center;
			}
			#counters {
				cursor: none;
				user-select: none;
				color: red;
				font-family: 'digital-clock-font';
				font-size: 100vmin;
			}
			fieldset.expandable>legend, .clickable {
				cursor: pointer;
				user-select: none;
			}
			fieldset.expandable>legend::after {
				content: ' â–¼';
			}
			fieldset.expandable.collapsed>legend::after {
				content: ' â–²';
			}
			fieldset.expandable.collapsed>:not(legend) {
				display: none;
			}
			.hidden {
				display: none;
			}
			.invisible {
				visibility: hidden;
			}
		</style>
		<script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
		<script>
			'use strict'
			function a(){
				let element_joinRoom = document.getElementById('join-room');
				let element_admin = document.getElementById('admin');
				let element_peerId = document.getElementById('peer-id');
				let element_peerIdSelect = document.getElementById('peer-id-select');
				let element_btnJoin = document.getElementById('btn-join');
				let element_btnHost = document.getElementById('btn-host');
				let element_terminals = document.getElementById('terminals');
				let element_terminal = document.getElementById('terminal');
				let element_addQueue = document.getElementById('add-queue');
				let element_queues = document.getElementById('queues');
				let element_terminalConfig = document.getElementById('terminal-config');
				let element_terminalConfig_nickname = document.getElementById('terminal-config-nickname');
				let notification = new Audio('Computer Error-SoundBible.com-1655839472.wav');
				let peer;
				let updateUICallback = ()=>console.error('Callback `updateUICallback` is not defined.');
				window.onhashchange = ()=>{
					element_peerIdSelect.value = location.hash.substr(1);
				}
				window.onhashchange();
				element_btnHost.addEventListener('click', ()=>{
					updateUICallback = ()=>{
						state.terminals.forEach(t => {
							let terminalItem_name = document.getElementById('terminal-'+t.id+'-name');
							terminalItem_name.innerHTML = t.nickname ? t.nickname : t.id;
						})
					}
					let state = {
						terminals: [],
						queues: [
							/*{ // Example
								name: 'name',
								value: 0,
								ticketsRaised: 1
							}*/
						]
					};
					let connections = [];
					function syncState(previousState){
						let currentState = JSON.stringify(state);
						if(previousState !== currentState){
							updateUICallback();
							connections.forEach(dataConnection => {
								dataConnection.send({type: 'state-update', value: JSON.parse(currentState)});
							});
						}
						setTimeout(syncState, 100, currentState);
					}
					syncState();
					function addTerminal(dataConnection){
						connections.push(dataConnection);
						state.terminals.push({
							id: dataConnection.peer,
								nickname: '',
								display: [
									/*{
										queue: 'name',
										displayName: false,
										ticketRaiser: false
									}*/
								]
						});
						let div = document.createElement('div');
						let speakerCheckbox = document.createElement('input');
						div.id = 'terminal-'+dataConnection.peer;
						div.classList.add('terminal-item');
						speakerCheckbox.type = 'checkbox';
						speakerCheckbox.classList.add('speaker');
						div.appendChild(speakerCheckbox);
						let terminalName = document.createElement('label');
						terminalName.innerHTML = '<span id="terminal-'+dataConnection.peer+'-name">'+dataConnection.peer+'</span> ðŸ”§';
						terminalName.classList.add('clickable');
						terminalName.onclick = ()=>{
							element_terminals.classList.add('hidden');
							element_queues.classList.add('hidden');
							state.terminals.filter(t => t.id === dataConnection.peer).forEach(t => {
								element_terminalConfig_nickname.value = t.nickname;
								element_terminalConfig_nickname.placeholder = t.id;
							});
							element_terminalConfig.classList.remove('hidden');
							document.getElementById('terminal-config-id').innerHTML = 'Terminal '+terminalName.innerHTML;
							document.getElementById('terminal-config-save').onclick = ()=>{
								state.terminals.filter(t => t.id === dataConnection.peer).forEach(t => {
									t.nickname = element_terminalConfig_nickname.value;
								});
								element_terminalConfig.classList.add('hidden');
								element_terminals.classList.remove('hidden');
								element_queues.classList.remove('hidden');
							};
						}
						div.appendChild(terminalName);
						element_terminals.appendChild(div);
					}
					function removeTerminal(dataConnection){
						[
							{
								index: state.terminals.findIndex(d => d.id === dataConnection.peer), 
								array: state.terminals
							},
							{
								index: connections.findIndex(d => d === dataConnection),
								array: connections
							}
						].forEach(o => {
							if(-1 < o.index){
								o.array.splice(o.index, 1);
							}
						});
						let div = document.getElementById('terminal-'+dataConnection.peer);
						div.parentElement.removeChild(div);
					}
					element_addQueue.addEventListener('click', ()=>{
						function validateAndUpdate(){
							if(0 < queueNumber.max){
								queueNumber.valueAsNumber = Math.max(queueNumber.min, queueNumber.valueAsNumber%queueNumber.max);
							}
							state.queues.filter(q => q.name === legend.innerHTML).forEach(q => q.value = queueNumber.valueAsNumber);
						}
						let fieldset = document.createElement('fieldset');
						fieldset.classList.add('expandable');
						let legend = document.createElement('legend');
						do{
							legend.innerHTML = prompt('Name of the queue:');
							if(legend.innerHTML === ''){
								alert('Error: Queue has to have a name.');
							}
							if([...document.getElementsByTagName('legend')].find(l => l.innerHTML === legend.innerHTML)){
								alert('Error: Name already given to another queue.');
								legend.innerHTML = '';
							}
						}while(legend.innerHTML === '');
						fieldset.appendChild(legend);
						let queueNumber = document.createElement('input');
						queueNumber.type = 'number';
						queueNumber.value = 1;
						queueNumber.min = 1;
						queueNumber.onkeyup = keyboardEvent => {
							if(keyboardEvent.code === 'Space'){
								queueNumber.valueAsNumber++;
								validateAndUpdate();
							}
						}
						queueNumber.onchange = validateAndUpdate;
						fieldset.appendChild(queueNumber);
						let queueNumberMax = document.createElement('input');
						queueNumberMax.type = 'number';
						queueNumberMax.value = 9;
						queueNumberMax.min = 0;
						queueNumberMax.onchange = ()=>{
							queueNumber.max = 0 < queueNumberMax.valueAsNumber ? queueNumberMax.valueAsNumber+1 : undefined;
						};
						queueNumberMax.onchange(),
						fieldset.appendChild(queueNumberMax);
						element_queues.appendChild(fieldset);
					});
					document.body.addEventListener('click', pointerEvent=>{
						if(pointerEvent.srcElement.localName === 'legend' && pointerEvent.srcElement.parentElement.classList.contains('expandable')){
							pointerEvent.srcElement.parentElement.classList.toggle('collapsed');
						}
					});
					peer = createPeer(element_peerIdSelect.value.toLocaleLowerCase(), ID => {
						location.hash = ID;
						element_peerId.innerHTML = ID;
						element_admin.classList.remove('hidden');
						peer.on('connection', dataConnection => {
							dataConnection.on('open', ()=>{
								addTerminal(dataConnection);
								dataConnection.send(state);
							});
							dataConnection.on('data', data => {
								switch(data.type){
									case 'queue-change':
										break
								}
							});
							dataConnection.on('close', ()=>{
								removeTerminal(dataConnection);
							});
						});
					});
				});
				element_btnJoin.addEventListener('click', ()=>{
					element_joinRoom.classList.add('hidden');
					//document.getElementById('select-mode').classList.remove('hidden');
					console.log('// TODO: Display `select-mode` to allow multiple admins in the future.');
					element_terminal.classList.remove('hidden')
					peer = createPeer(undefined, ID=>{
						updateUICallback = state=>{
							state.terminals.filter(t => t.id === ID).forEach(thisTerminal => {
								if(!thisTerminal.display.length){
									document.getElementById('terminal-id').innerHTML = thisTerminal.nickname ? thisTerminal.nickname : thisTerminal.id;
								}
							})
						}
						let id = element_peerIdSelect.value.toLocaleLowerCase();
						let dataConnection = peer.connect(id);
						dataConnection.on('open', ()=>{
							location.hash = id;
							// Send messages
							dataConnection.send('2!');
							// Receive messages
							dataConnection.on('data', data => {
								switch(data.type){
									case 'state-update':
										updateUICallback(data.value);
										break
								}
							});
						});
						dataConnection.on('close', ()=>{
							location.reload();
						});
					});
				});
				function createPeer(id='', callback=()=>{}){
					let peer = new Peer(id);
					element_peerIdSelect.disabled = true;
					element_btnHost.disabled = true;
					element_btnJoin.disabled = true;
					peer.on('open', ID =>{
						element_joinRoom.classList.add('hidden');
						callback(ID);
					});
					peer.on('error', err => {
						element_peerIdSelect.disabled = false;
						element_btnHost.disabled = false;
						element_btnJoin.disabled = false;
						document.getElementById('error-message').innerHTML = err;
						document.getElementById('error-message').classList.remove('invisible');
					});
					return peer;
				}
				function raise(elementCounter){
					let currentValue = parseInt(elementCounter.innerHTML);
					let max = parseInt(elementCounter.max);
					debugger
					elementCounter.innerHTML = Math.max(1, (currentValue+1)%currentMax);
					notification.play();
				}
			}
		</script>
	</head>
	<body onload="a()">
		<div id="join-room" class="center-height">
			<div>
				<div class="center-width">
					<i>Queue ID</i>
				</div>
				<div class="center-width">
					<input id="peer-id-select" type="text">
				</div>
				<div class="center-width">
					<input id="btn-host" type="button" value="Host">
					<input id="btn-join" type="button" value="Join">
				</div>
				<div id="error-message" class="invisible center-width"></div>
			</div>
		</div>
		<div id="select-mode" class="hidden"></div>
		<div id="admin" class="hidden">
			<div>
				<div>
					<b>Queue ID:</b>
					<span id="peer-id"></span>
				</div>
				<div>
					<fieldset id="terminals" class="expandable">
						<legend>Terminals</legend>
						<input id="speaker" type="button" value="Speak">
					</fieldset>
					<fieldset id="queues" class="expandable">
						<legend>Queues</legend>
						<input id="add-queue" type="button" value="Add queue">
					</fieldset>
				</div>
				<fieldset id="terminal-config" class="hidden">
					<legend id="terminal-config-id"></legend>
					<fieldset>
						<legend>Config</legend>
						<label for="terminal-config-nickname">Name</label>
						<input id="terminal-config-nickname" type="text" value="">
						<input id="terminal-config-display-name" type="checkbox">
						<label for="terminal-config-display-name">Display name</label>
					</fieldset>
					<div id="terminal-config-queues">
						<fieldset>
							<legend>Available queues</legend>
						</fieldset>
						<fieldset>
							<legend>Selected queues</legend>
						</fieldset>
					</div>
					<input id="terminal-config-save" type="button" value="Save">
				</fieldset>
			</div>
		</div>
		<div id="terminal" class="hidden">
			<div class="center-height">
				<div>
					<div id="terminal-id" class="center-width"></div>
				</div>
			</div>
		</div>
		<div id="queue-ticket" class="hidden">
			<!--
				TODO:
					1. List all queues.
					2. When click on queue, next ticket is displayed and stored.
					3. When ticket is current a sound is played from device.
			-->
		</div>
	</body>
</html>
